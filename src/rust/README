How to use Rust code in NK, plus an example.

STRUCTURE
---------

Rust code lives under `src/rust`.   What's immediately under that
tree is glue code, with an example Rust module.  

SETUP
-----

DO NOT INSTALL "RELEASE" VERSIONS OF RUST.

YOU NEED TO INSTALL A PER-USER COPY OF THE NIGHTLY BUILD TO HAVE THE
RIGHT FEATURES.

Yes, this fantastic evidence of stability of this tool for kernel
development...

Install [rustup](http://rustup.rs), currently via:

`curl https://sh.rustup.rs -sSf | sh`

This will install tools in ~/.cargo/bin, which you will want to
put on your path.

`source ~/.cargo/env`

You will want a file in the top level Rust module's directory called
"rust-toolchain" whose contents should be "nightly"

Also install the cargo xbuild so it can cross-compile Rust-dependent
libraries for us:

`cargo install cargo-xbuild`

And we need the rust sources for it to work on:

`rustup toolchain install nightly --component rust-src`

CREATE A NEW RUST MODULE
------------------------

The basic idea here is that we will build a static library in Rust
and then link that with NK.     Do this under src/rust.

First create a new module by doing EITHER:

- add a `[module name].rs` file to `src` OR
- add a `[module name]` directory to `src` and create a `mod.rs` file under that directory

Now add the new module to `lib.rs` by inserting `mod [module name];`.

modify the new module source file in line with our examples

Any functon you want to export has to look like:

#[no_mangle]
pub extern "C" fn functionaname(...) -> ... { ... }

Copy `glue/example.c`:

`cp glue/example.c glue/[module name].c`

The glue code here (and in the top-level rust directory) force
the damned linkage to work as you would expect despite Rust's
static library model.

Modify Makefile to reflect your module name and directory locations
(this is currently gruesomely hacked in the KBuild process, which
assumes that all commands run from the root of the project tree).

Modify glue.c to reflect your exported symbols.  Push every exported
function, variable, or pointer through nk_rust_link_fakery.  The types
do not matter.  The function will never be called.  We just do not
want the linker to lose anything, and we cannot use --whole-archive
here because Rust itself exports unmangled conflicting symbols like
memmove that will break the build at the parent directory. 

Finally, insert `#include "glue/[module name].c"` to `glue.c`

CALLING INTO THE RUST MODULE
----------------------------

The only thing tested at this point is invoking a trivial Rust
function from C. The "test rust" command from the shell will do this.
The relevant code from shell.c shows how to do it.   In particular:
declare the function's C prototype and call it.

We do not yet know how to do:

1. Nontrivial functions
2. Rust->C callbacks
3. Access to C structures/pointers from Rust (Swig?)
4. Threads ?!
5. All other things

BUILDING
--------

Enable Rust support in make menuconfig -> Build -> Enable Rust support

Build NK as usual. Run `rust` to see if the example works.
